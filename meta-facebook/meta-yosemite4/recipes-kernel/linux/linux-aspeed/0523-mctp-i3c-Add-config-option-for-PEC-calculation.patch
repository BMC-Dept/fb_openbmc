From e41faef708571bbaa5ab75bd36024ee4b02de0a1 Mon Sep 17 00:00:00 2001
From: Marvin Lin <milkfafa@gmail.com>
Date: Thu, 28 Dec 2023 11:30:50 +0800
Subject: [PATCH] mctp i3c: Add config option for PEC calculation

Add config option for PEC calculation.

Signed-off-by: cpchiang <cpchiang1@nuvoton.com>
---
 drivers/net/mctp/Kconfig    |  9 +++++++++
 drivers/net/mctp/mctp-i3c.c | 13 +++++++++++++
 2 files changed, 22 insertions(+)

diff --git a/drivers/net/mctp/Kconfig b/drivers/net/mctp/Kconfig
index ce9d2d2ccf3b..07bd05872c93 100644
--- a/drivers/net/mctp/Kconfig
+++ b/drivers/net/mctp/Kconfig
@@ -42,6 +42,15 @@ config MCTP_TRANSPORT_I3C
 	  A MCTP protocol network device is created for each I3C bus
 	  having a "mctp-controller" devicetree property.
 
+config MCTP_TRANSPORT_I3C_PEC
+	tristate "MCTP I3C transport support PEC"
+	depends on MCTP_TRANSPORT_I3C
+	default y
+	help
+	  Some mctp i3c devices disable PEC check since it cost much time to
+	  calculate the result of PEC.
+	  Provides a choice to enable/disable append pec byte.
+
 endmenu
 
 endif
diff --git a/drivers/net/mctp/mctp-i3c.c b/drivers/net/mctp/mctp-i3c.c
index 2672e0b272f8..69fc0f9e6f4b 100644
--- a/drivers/net/mctp/mctp-i3c.c
+++ b/drivers/net/mctp/mctp-i3c.c
@@ -140,6 +140,7 @@ static int mctp_i3c_read(struct mctp_i3c_device *mi)
 		goto err;
 	}
 
+#ifdef CONFIG_MCTP_TRANSPORT_I3C_PEC
 	/* check PEC, including address byte */
 	addr = mi->addr << 1 | 1;
 	pec = i2c_smbus_pec(0, &addr, 1);
@@ -152,6 +153,9 @@ static int mctp_i3c_read(struct mctp_i3c_device *mi)
 
 	/* Remove PEC */
 	skb_trim(skb, xfer.len - 1);
+#else
+	skb_trim(skb, xfer.len);
+#endif
 
 	cb = __mctp_cb(skb);
 	cb->halen = PID_SIZE;
@@ -161,7 +165,11 @@ static int mctp_i3c_read(struct mctp_i3c_device *mi)
 
 	if (net_status == NET_RX_SUCCESS) {
 		stats->rx_packets++;
+#ifdef CONFIG_MCTP_TRANSPORT_I3C_PEC
 		stats->rx_bytes += xfer.len - 1;
+#else
+		stats->rx_bytes += xfer.len;
+#endif
 	} else {
 		stats->rx_dropped++;
 	}
@@ -381,6 +389,7 @@ static void mctp_i3c_xmit(struct mctp_i3c_bus *mbus, struct sk_buff *skb)
 	if (WARN_ON_ONCE(data_len + 1 > MCTP_I3C_MAXBUF))
 		goto out;
 
+#ifdef CONFIG_MCTP_TRANSPORT_I3C_PEC
 	if (data_len + 1 > (unsigned int)mi->mwl) {
 		/* Route MTU was larger than supported by the endpoint */
 		stats->tx_dropped++;
@@ -405,6 +414,10 @@ static void mctp_i3c_xmit(struct mctp_i3c_bus *mbus, struct sk_buff *skb)
 	data[data_len] = pec;
 
 	xfer.data.out = data;
+#else
+	xfer.len = data_len;
+	xfer.data.out = skb->data;
+#endif
 	rc = i3c_device_do_priv_xfers(mi->i3c, &xfer, 1);
 	if (rc == 0) {
 		stats->tx_bytes += data_len;
-- 
2.25.1

