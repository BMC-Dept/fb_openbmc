From 7ec2f8daa3a8948066390aee621d6afa03f6ecd9 Mon Sep 17 00:00:00 2001
From: Andrew Jeffery <andrew@codeconstruct.com.au>
Date: Wed, 20 Dec 2023 17:31:55 +1030
Subject: [PATCH 03/23] mctpd: Add support for endpoint recovery

DSP0236 v1.3.1[1] 8.17.6 defines a process for reclaiming dynamically
assigned EIDs from endpoint devices that have been removed from the
network. The fundamental process is captured in the following paragraphs:

> - The bus owner shall wait at least `Treclaim` seconds before
>   reassigning a given EID (where `Treclaim` is specified in the
>   physical transport binding specification for the medium used to
>   access the endpoint).
>
> - Reclaimed EIDs shall only be reassigned after all unused EIDs in the
>   EID pool have been assigned to endpoints. Optionally, additional
>   robustness can be achieved if the bus owner maintains a short FIFO
>   list of reclaimed EIDs (and their associated physical addresses) and
>   allocates the older EIDs first.
>
> - A bus owner shall confirm that an endpoint has been removed by
>   attempting to access it after `Treclaim` has expired. It can do this
>   by issuing a `Get Endpoint ID` command to the endpoint to verify
>   that the endpoint is still non-responsive. It is recommended that
>   this be done at least three times, with a delay of at least `1/2 *
>   Treclaim` between tries if possible. If the endpoint continues to be
>   non-responsive, it can be assumed that it is safe to return its EID
>   to the pool of EIDs available for assignment.

[1]: https://www.dmtf.org/sites/default/files/standards/documents/DSP0236_1.3.1.pdf

The extract is framed with the perspective of reclaiming an unused EID
but we must consider the broader case of unresponsiveness - we don't yet
understand whether an EID should even be reclaimed. However, we can use
the mechanisms outlined - polling using `Get Endpoint ID` - to achieve
this understanding.

We wish to avoid continuous polling of devices by `mctpd` for a few
reasons:

1. Interleaving of commands to simple endpoints that may not cope
2. The increase in bus utilisation increases the probability of
   contention and loss of arbitration

Given this, daemons using MCTP as a transport need some way to request
that mctpd start polling the device to recover it or reclaim its EID.

The strategy implemented adds a `.Recover` method and a `.Connectivity`
property to the `au.com.CodeConstruct.MCTP.Endpoint` interface.
`.Recover` takes no arguments, produces no result, and returns
immediately. `.Connectivity` takes one of two values:

- `Available`
- `Degraded`

When `.Recover` is invoked `mctpd` transitions `.Connectivity` to
`Degraded`, then queries the device with `Get Endpoint ID`. `.Recover`
responds on D-Bus after `Get Endpoint ID` has been issued and before a
response is received.  A valid response received from a `Get Endpoint
ID` query transmitted inside `Treclaim` leads to `.Connectivity`
transitioning to `Available`. If a response is not received to a `Get
Endpoint ID` query issued inside `Treclaim` then `mctpd` removes the
endpoint's D-Bus object.

```mermaid
stateDiagram-v2
  [*] --> Available
  Available --> Degraded
  Degraded --> Available
  Degraded --> [*]
```

The impact of changes to `.Connectivity` can be divided across two
classes of client application:

1. The application invoking `.Recover` on a given endpoint `A`
2. Applications communicating with `A` that have not entered a state
   where recovery was considered necessary

For an application to invoke `.Recover` it must already consider the
endpoint unresponsive, therefore it seems reasonable to assume it won't
continue communicating with the endpoint unless the recovery succeeds.
As such there's no action required when `.Connectivity` transitions to
`Degraded`. However, if recovery succeeds, the transition of
`.Connectivity` from `Degraded` to `Available` provides the signal to
restart communicating with the endpoint.

For applications in the second class it is likely the case that they
haven't themselves invoked `.Recover` because they are yet to observe a
communication failure with the endpoint. As such there's also no
requirement for action when `.Connectivity` transitions to `Degraded` on
behalf of another application. However, it may be the case that
communication failures are subsequently observed. It's not necessary to
invoke `.Recover` if `.Connectivity` is already in `Degraded`, though
there should also be no significant consequences if it occurs. If no
communication failures are observed while `.Connectivity` is in
`Degraded` then there's also no action required if it transitions to
`Available`.

Signed-off-by: Andrew Jeffery <andrew@codeconstruct.com.au>
---
 CHANGELOG.md              |   4 +
 docs/endpoint-recovery.md | 434 ++++++++++++++++++++++++++++++++++++++
 src/mctpd.c               | 276 ++++++++++++++++++++++++
 3 files changed, 714 insertions(+)
 create mode 100644 docs/endpoint-recovery.md

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7557b78..3220d01 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,6 +6,10 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 
 ## Unreleased
 
+### Added
+
+1. mctpd: Add support for endpoint recovery
+
 ### Changed
 
 1. dbus interface: the NetworkID field is now a `u` rather than an `i`, to
diff --git a/docs/endpoint-recovery.md b/docs/endpoint-recovery.md
new file mode 100644
index 0000000..63180c1
--- /dev/null
+++ b/docs/endpoint-recovery.md
@@ -0,0 +1,434 @@
+# Endpoint Recovery
+
+<!--toc:start-->
+- [Endpoint Recovery](#endpoint-recovery)
+  - [References](#references)
+  - [Relevant components](#relevant-components)
+  - [Concerns](#concerns)
+  - [Behaviours](#behaviours)
+  - [Relevant MCTP commands, behaviours, and requirement constraints](#relevant-mctp-commands-behaviours-and-requirement-constraints)
+  - [Requesting endpoint recovery from `mctpd`](#requesting-endpoint-recovery-from-mctpd)
+  - [Endpoint health determinations and consequences](#endpoint-health-determinations-and-consequences)
+  - [D-Bus interface discussion](#d-bus-interface-discussion)
+  - [Proposed Design](#proposed-design)
+    - [`.Recover` method design considerations](#recover-method-design-considerations)
+    - [Application behaviours over an endpoint recovery sequence](#application-behaviours-over-an-endpoint-recovery-sequence)
+    - [`mctpd` behaviours over an endpoint recovery sequence](#mctpd-behaviours-over-an-endpoint-recovery-sequence)
+  - [MCTP device lifecycle and consuming events from `mctpd` D-Bus objects](#mctp-device-lifecycle-and-consuming-events-from-mctpd-d-bus-objects)
+    - [An example order of MCTP device events, consumed by `nvmesensor`](#an-example-order-of-mctp-device-events-consumed-by-nvmesensor)
+<!--toc:end-->
+
+Here we capture some reasoning around a design and implementation of device
+presence detection and EID reclaim.
+
+## References
+
+1. [DSP0236 - Management Component Transport Protocol (MCTP) Base Specification][dmtf-dsp0236]
+2. [DSP0237 - Management Component Transport Protocol (MCTP) SMBus/I2C Transport Binding Specification][dmtf-dsp0237]
+3. [DSP0239 - Management Component Transport Protocol (MCTP) IDs and Codes][dmtf-dsp0239]
+3. [Freedesktop: D-Bus Specification][dbus-spec]
+
+[dmtf-dsp0236]: https://www.dmtf.org/sites/default/files/standards/documents/DSP0236_1.3.1.pdf
+[dmtf-dsp0237]: https://www.dmtf.org/sites/default/files/standards/documents/DSP0237_1.2.0.pdf
+[dmtf-dsp0239]: https://www.dmtf.org/sites/default/files/standards/documents/DSP0239_1.10.0.pdf
+[dbus-spec]: https://dbus.freedesktop.org/doc/dbus-specification.html
+
+## Relevant components
+
+1. Endpoint devices, such as NVMe drives
+2. I2C buses
+3. `fru-device`
+4. `entity-manager`
+5. Client applications, such as `nvmesensor`
+6. `mctpd`
+
+## Concerns
+
+It's reasonable for clients like `nvmesensor` to identify issues with the NVMe
+subsystem, but it's possible that communication errors could be a result of
+issues on the underlying transport.
+
+We try to place the detection and recovery effort at the appropriate layer in
+the communication stack.
+
+Concretely, `nvmesensor` periodically issues a `Controller Health Status Poll`
+to monitored drives. Polling may fail due to issues with the subsystem or due to
+more fundamental issues like the endpoint being removed from the bus. In the
+cases where `nvmesensor` determines it shouldn't own the problem of monitoring
+for resumed communications it should punt the polling to `mctpd`.
+
+## Behaviours
+
+Reasons for temporary loss of e.g. NVMe-MI communication at the MCTP layer
+include:
+
+1. I2C bus recovery by the controller
+2. I2C bus contention and loss of arbitration
+3. Transparent MCTP proxy hardware dropping communication
+4. Hot-(un)plug of the endpoint device
+
+## Relevant MCTP commands, behaviours, and requirement constraints
+
+1. Use of `Get Endpoint ID` for polling
+2. Use of `Get Endpoint UUID` to track device exchange
+
+Substatiating 1, from [DSP0236 v1.3.1 8.17.6 Reclaiming EIDs from hot-plug
+devices][dmtf-dsp0236] we have:
+
+> - The bus owner shall wait at least `Treclaim` seconds before reassigning a
+>   given EID (where `Treclaim` is specified in the physical transport binding
+>   specification for the medium used to access the endpoint).
+>
+> - Reclaimed EIDs shall only be reassigned after all unused EIDs in the EID
+>   pool have been assigned to endpoints. Optionally, additional robustness
+>   can be achieved if the bus owner maintains a short FIFO list of reclaimed
+>   EIDs (and their associated physical addresses) and allocates the older EIDs
+>   first.
+>
+> - A bus owner shall confirm that an endpoint has been removed by attempting
+>   to access it after `Treclaim` has expired. It can do this by issuing a `Get
+>   Endpoint ID` command to the endpoint to verify that the endpoint is still
+>   non-responsive. It is recommended that this be done at least three times,
+>   with a delay of at least `1/2 * Treclaim` between tries if possible. If the
+>   endpoint continues to be non-responsive, it can be assumed that it is safe
+>   to return its EID to the pool of EIDs available for assignment.
+
+We're concerned with the `Treclaim` relevant to NVMe-MI devices for now, which
+leads us to DSP0237. [DSP0237 v1.2.0 6.19][dmtf-dsp0237] defines `Treclaim` as 5
+seconds. The same section also defines `MN1` (Number of request retries) with a
+minimum of `2`. A retry is specifically a transmission attempt after the initial
+transmission, so an `MN1` minimum of 2 implies at least three messages will be
+sent, in line with the suggestion from DSP0236.
+
+## Requesting endpoint recovery from `mctpd`
+
+We wish to avoid continuous polling of devices by `mctpd` for a few reasons:
+
+1. Interleaving of commands to simple endpoints
+2. The increase bus utilisation increases the probability of contention and loss
+   of arbitration
+
+Given this, `nvmesensor` and any other daemons using MCTP as a transport need
+some way to request polling be performed. `mctpd` already exposes D-Bus APIs for
+endpoint management - we will add another for this purpose.
+
+## Endpoint health determinations and consequences
+
+There are several possible outcomes upon an application such as `nvmesensor`
+requesting `mctpd` recover communication with an endpoint:
+
+1. `mctpd` issues `Get Endpoint ID` to the device and finds no sign of failure -
+   the device responds without requiring a retry.
+
+2. `mctpd` issues `Get Endpoint ID` to the device and initially finds it
+   unresponsive, but the device recovers and responds to a retry attempt before
+   `Treclaim`.
+
+3. `mctpd` issues `Get Endpoint ID` to the device. The device fails to respond
+   to the initial query and all subsequent retries up to `Treclaim`.
+
+In the case of the third scenario MCTP defines the device as removed until some
+later event re-establishes its presence. If a device is considered removed then
+the D-Bus object representing the device must also be removed.
+
+Conversely, in scenarios 1 and 2 the device should not be considered removed
+as communication was re-established prior to `Treclaim`. Until `Treclaim` the
+device exists in an intermediate state where it's expected to be present but
+its presence is undetermined. As such, its D-Bus object should also remain, but
+we need to acknowledge to interested applications that there are communication
+issues. This may include applications in addition to the process which requested
+`mctpd` recover communication with the endpoint.
+
+## D-Bus interface discussion
+
+`mctpd` currently structures its D-Bus objects as follows:
+
+```
+root@cc-nvme-mi:~# busctl tree xyz.openbmc_project.MCTP
+`-/xyz
+  `-/xyz/openbmc_project
+    `-/xyz/openbmc_project/mctp
+      `-/xyz/openbmc_project/mctp/1
+        |-/xyz/openbmc_project/mctp/1/12
+        |-/xyz/openbmc_project/mctp/1/8
+        `-/xyz/openbmc_project/mctp/1/9
+```
+
+```
+root@cc-nvme-mi:~# busctl introspect xyz.openbmc_project.MCTP /xyz/openbmc_project/mctp
+NAME                                TYPE      SIGNATURE  RESULT/VALUE  FLAGS
+au.com.CodeConstruct.MCTP           interface -          -             -
+.AssignEndpoint                     method    say        yisb          -
+.LearnEndpoint                      method    say        yisb          -
+.SetupEndpoint                      method    say        yisb          -
+org.freedesktop.DBus.Introspectable interface -          -             -
+.Introspect                         method    -          s             -
+org.freedesktop.DBus.ObjectManager  interface -          -             -
+.GetManagedObjects                  method    -          a{oa{sa{sv}}} -
+.InterfacesAdded                    signal    oa{sa{sv}} -             -
+.InterfacesRemoved                  signal    oas        -             -
+org.freedesktop.DBus.Peer           interface -          -             -
+.GetMachineId                       method    -          s             -
+.Ping                               method    -          -             -
+org.freedesktop.DBus.Properties     interface -          -             -
+.Get                                method    ss         v             -
+.GetAll                             method    s          a{sv}         -
+.Set                                method    ssv        -             -
+.PropertiesChanged                  signal    sa{sv}as   -             -
+```
+
+```
+root@cc-nvme-mi:~# busctl introspect xyz.openbmc_project.MCTP /xyz/openbmc_project/mctp/1
+NAME                                TYPE      SIGNATURE RESULT/VALUE FLAGS
+org.freedesktop.DBus.Introspectable interface -         -            -
+.Introspect                         method    -         s            -
+org.freedesktop.DBus.Peer           interface -         -            -
+.GetMachineId                       method    -         s            -
+.Ping                               method    -         -            -
+org.freedesktop.DBus.Properties     interface -         -            -
+.Get                                method    ss        v            -
+.GetAll                             method    s         a{sv}        -
+.Set                                method    ssv       -            -
+.PropertiesChanged                  signal    sa{sv}as  -            -
+```
+
+```
+root@cc-nvme-mi:~# busctl introspect xyz.openbmc_project.MCTP /xyz/openbmc_project/mctp/1/9
+NAME                                TYPE      SIGNATURE RESULT/VALUE                           FLAGS
+au.com.CodeConstruct.MCTP.Endpoint  interface -         -                                      -
+.Remove                             method    -         -                                      -
+.SetMTU                             method    u         -                                      -
+org.freedesktop.DBus.Introspectable interface -         -                                      -
+.Introspect                         method    -         s                                      -
+org.freedesktop.DBus.Peer           interface -         -                                      -
+.GetMachineId                       method    -         s                                      -
+.Ping                               method    -         -                                      -
+org.freedesktop.DBus.Properties     interface -         -                                      -
+.Get                                method    ss        v                                      -
+.GetAll                             method    s         a{sv}                                  -
+.Set                                method    ssv       -                                      -
+.PropertiesChanged                  signal    sa{sv}as  -                                      -
+xyz.openbmc_project.Common.UUID     interface -         -                                      -
+.UUID                               property  s         "595a522d-77c5-4628-8400-37bfb41b710c" const
+xyz.openbmc_project.MCTP.Endpoint   interface -         -                                      -
+.EID                                property  y         9                                      const
+.NetworkId                          property  i         1                                      const
+.SupportedMessageTypes              property  ay        1 0                                    const
+```
+
+The problem we have deals with specific endpoints. To satisfy the third scenario
+the object `/xyz/openbmc_project/mctp/1/9` would be removed.
+
+For scenarios 1 and 2 we need to add capabilities on the endpoint object. The
+`au.com.CodeConstruct.MCTP.Endpoint` already exposes endpoint control APIs, and
+given we're not removing capabilities we can change it.
+
+## Proposed Design
+
+The approach is to add a `.Recover` method and a `.Connectivity` property to the
+`au.com.CodeConstruct.MCTP.Endpoint` interface. `.Recover` takes no arguments,
+produces no result, and returns immediately. `.Connectivity` takes one of two
+values:
+
+- `Available`
+- `Degraded`
+
+When `.Recover` is invoked `mctpd` transitions `.Connectivity` to `Degraded`,
+then queries the device with `Get Endpoint ID`. `.Recover` responds on D-Bus
+after `Get Endpoint ID` has been issued and before a response is received.
+A valid response received from a `Get Endpoint ID` query transmitted inside
+`Treclaim` leads to `.Connectivity` transitioning to `Available`. If a response
+is not received to a `Get Endpoint ID` query issued inside `Treclaim` then
+`mctpd` removes the endpoint's D-Bus object.
+
+```mermaid
+stateDiagram-v2
+  [*] --> Available
+  Available --> Degraded
+  Degraded --> Available
+  Degraded --> [*]
+```
+
+### `.Recover` method design considerations
+
+There are several possible design points for `.Recover`:
+
+1. Withold a response until communication with the device is recovered or the
+   device is considered removed after `Treclaim`, and respond with the overall
+   result
+
+2. Withold a response until the first `Get Endpoint ID` query has resolved,
+   either via a timely response or via a timeout, and respond with the result of
+   this first query
+
+3. Immediately respond prior to resolving the first `Get Endpoint ID query`
+   without providing a result
+
+Option 1 is not feasible for two reasons:
+
+- DSP0236 punts definition of `Treclaim` to the transport binding
+  specifications, and
+
+- D-Bus punts the entire concept of method call timeouts to the
+  implementation[^1], which are often configurable
+
+[^1]: As best I can see there's no definition of timeouts in the [method call
+      section of the specification][dbus-spec-message-protocol-types-method].
+      [`4a85d321b451`][dbus-reference-timeout-commit] is the first introduction
+      of the concept of method call timeouts in the D-Bus reference
+      implementation, back in 2003.
+
+[dbus-spec-message-protocol-types-method]: https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-types-method
+[dbus-reference-timeout-commit]: https://gitlab.freedesktop.org/dbus/dbus/-/commit/4a85d321b4516c6a663e8bdd530ba59018c974df
+
+As we can't assume appropriate values for either of those behaviours we should
+design an interfaces that avoids putting constraints on them. This drives
+introducing the `.Connectivity` member as an asynchronous signal of recovery
+progress.
+
+Option 3 requires we rely entirely on signals from `.Connectivity` to drive
+a state machine in interested applications. This may feel heavy-handed and
+thus tempting to implement option 2 for the happy case where recovery
+immediately succeeds. However, option 2 requires interested applications
+implement two separate code paths to handle recovery, which seems questionable
+from the perspective of correctness, robustness and maintenance.
+
+### Application behaviours over an endpoint recovery sequence
+
+The impact of changes to `.Connectivity` can be divided across two classes of
+application:
+
+1. The application invoking `.Recover` on a given endpoint `A`
+2. Applications communicating with `A` that have not entered a state where
+   recovery was considered necessary
+
+For an application to invoke `.Recover` it must already consider the endpoint
+unresponsive, therefore it seems reasonable to assume it won't continue
+communicating with the endpoint unless the recovery succeeds. As such there's
+no action required when `.Connectivity` transitions to `Degraded`. However,
+if recovery succeeds, the transition of `.Connectivity` from `Degraded` to
+`Available` provides the signal to restart communicating with the endpoint.
+
+For applications in the second class it is likely the case that they
+haven't themselves invoked `.Recover` because they are yet to observe a
+communication failure with the endpoint. As such there's also no requirement
+for action when `.Connectivity` transitions to `Degraded` on behalf of another
+application. However, it may be the case that communication failures are
+subsequently observed. It's not necessary to invoke `.Recover` if
+`.Connectivity` is already in `Degraded`, though there should also be no
+significant consequences if it occurs. If no communication failures are observed
+while `.Connectivity` is in `Degraded` then there's also no action required if
+it transitions to `Available`.
+
+### `mctpd` behaviours over an endpoint recovery sequence
+
+For hotplug devices recovering from a reset `Get Endpoint ID` should yield an
+EID of 0.
+
+Note that while we're under the `Treclaim` period the device's allocated EID has
+not been quarantined to the reuse FIFO, and is also not a member of the dynamic
+allocation pool. For the purposes of allocation, the device is still assigned
+the EID it had prior to taking a reset. If a device at the physical address of
+the device in `Degraded` responds to `Get Endpoint ID` with an EID of 0 inside
+the `Treclaim` period and has a UUID that matches the device in `Degraded`, then
+it should be reassigned its allocated EID. At the end of this sequence the
+reassignment should not be observable to MCTP-application-layer beyond the
+endpoint's `.Connectivity` member transitioning from `Degraded` to `Available`.
+
+## MCTP device lifecycle and consuming events from `mctpd` D-Bus objects
+
+The general strategy for tracking endpoint lifecycles is [as follows]
+[dbus-spec-standard-interfaces-objectmanager]:
+
+[dbus-spec-standard-interfaces-objectmanager]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager
+
+1. Add a match of the following form for event-driven updates to local
+   data-structures
+
+   ```
+   type='signal',sender='xyz.openbmc_project.MCTP',path_namespace='/xyz/openbmc_project/mctp'
+   ```
+
+2. Issue a call to `GetManagedObjects` `org.freedesktop.DBus.ObjectManager` on
+   `/xyz/openbmc_project/mctp` for initial population of local data-structures
+
+3. Issue
+
+### An example order of MCTP device events, consumed by `nvmesensor`
+
+1. A series of events yields a new FRU EEPROM device on an I2C bus already
+   registered as an MCTP endpoint.
+
+2. The FRU data is decoded and `SetupEndpoint` on the
+   `au.com.CodeConstruct.MCTP` interface of the `/xyz/openbmc_project/mctp`
+   object hosted by `mctpd` is invoked.
+
+3. The device was not previously configured and has no programmed static EID.
+   `mctpd` allocates an EID (9) from its dynamic pool and assigns it to the
+   device.
+
+4. `mctpd` [emits an `InterfacesAdded` signal][dbus-spec-standard-interfaces-objectmanager]
+   with the following contents (represented as JSON, trimmed to relevant
+   interfaces):
+
+   ```
+   "/xyz/openbmc_project/mctp/1/9": {
+     "au.com.CodeConstruct.MCTP.Endpoint": { },
+     "xyz.openbmc_project.Common.UUID": {
+       "UUID": "..."
+     },
+     "xyz.openbmc_project.MCTP.Endpoint": {
+       "EID": 9,
+       "NetworkId": 1,
+       "SupportedMessageTypes": [ 0, 4 ],
+     }
+   }
+   ```
+
+5. The device indicates support for message type `4`, ["NVM Express Management
+   Messages over MCTP"][dmtf-dsp0239]. `nvmesensor` updates its local data-structures to
+   capture the appearance of a new NVMe device.
+
+6. `nvmesensor` begins managing the NVMe device via NVMe-MI.
+
+7. MCTP endpoint 9 stops responding to NVMe-MI commands from `nvmesensor`.
+
+8. `nvmesensor` calls the `Recover` method on the
+   `au.com.CodeConstruct.MCTP.Endpoint` of the `/xyz/openbmc_project/mctp/1/9`
+   D-Bus object hosted by `mctpd`. This may occur via e.g. failure to regularly
+   poll the drive CTEMP.
+
+9. `mctpd` [emits a `PropertiesChanged` signal][dbus-spec-standard-interfaces-properties]
+   from `/xyz/openbmc_project/mctp/1/9` with the following contents:
+
+   ```
+   [
+     "au.com.CodeConstruct.MCTP.Endpoint",
+     { "Connectivity": "Degraded" },
+     { }
+   ]
+   ```
+
+10. `nvmesensor` receives the `Degraded` `PropertiesChanged` event moves the
+    drive's NVMe subsystem into the `Status::Stop` state
+
+11. `mctpd` polls for the presence of the device using `Get Endpoint ID` in accordance with
+    [8.17.6][dmtf-dsp0236]
+
+12. The device fails to respond to all (retried) queries issued inside `Treclaim`.
+
+13. `mctpd` removes `/xyz/openbmc_project/mctp/1/9` from D-Bus, emitting an
+    `InterfacesRemoved` signal with the following content
+
+    ```
+    "/xyz/openbmc_project/mctp/1/9": [
+      "au.com.CodeConstruct.MCTP.Endpoint",
+      "xyz.openbmc_project.MCTP.Endpoint",
+      ...
+    ]
+    ```
+
+14. `nvmesensor` receives the `InterfacesRemoved` signal and cleans up its
+    representation of the device from its idle state.
+
+[dbus-spec-standard-interfaces-properties]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties
diff --git a/src/mctpd.c b/src/mctpd.c
index 88a8506..724c10d 100644
--- a/src/mctpd.c
+++ b/src/mctpd.c
@@ -6,6 +6,9 @@
  * Copyright (c) 2021 Google
  */
 
+#include <assert.h>
+#include <bits/time.h>
+#include <systemd/sd-bus-vtable.h>
 #define _GNU_SOURCE
 
 #include <sys/socket.h>
@@ -112,6 +115,17 @@ struct peer {
 
 	// Stuff the ctx pointer into peer for tidier parameter passing
 	struct ctx *ctx;
+
+	// Connectivity state
+	bool degraded;
+	struct {
+		uint64_t delay;
+		sd_event_source *source;
+		int npolls;
+		mctp_eid_t eid;
+		uint8_t endpoint_type;
+		uint8_t medium_spec;
+	} recovery;
 };
 typedef struct peer peer;
 
@@ -1240,6 +1254,17 @@ static int remove_peer(peer *peer)
 	unpublish_peer(peer);
 
 	// Clear it
+	if (peer->degraded) {
+		int rc;
+
+		rc = sd_event_source_set_enabled(peer->recovery.source, SD_EVENT_OFF);
+		if (rc < 0) {
+			/* XXX: Fix caller assumptions? */
+			warnx("Failed to stop recovery timer while removing peer: %d", rc);
+		}
+		sd_event_source_unref(peer->recovery.source);
+	}
+
 	n->peeridx[peer->eid] = -1;
 	free(peer->message_types);
 	free(peer->uuid);
@@ -1587,6 +1612,46 @@ static int peer_set_uuid(peer *peer, const uint8_t uuid[16])
 	return 0;
 }
 
+static int
+query_get_peer_uuid_by_phys(ctx *ctx, const dest_phys *dest, uint8_t uuid[16])
+{
+	struct sockaddr_mctp_ext addr;
+	struct mctp_ctrl_cmd_get_uuid req;
+	struct mctp_ctrl_resp_get_uuid *resp = NULL;
+	uint8_t* buf = NULL;
+	size_t buf_size;
+	int rc;
+
+	req.ctrl_hdr.rq_dgram_inst = RQDI_REQ;
+	req.ctrl_hdr.command_code = MCTP_CTRL_CMD_GET_ENDPOINT_UUID;
+
+	rc = endpoint_query_phys(ctx, dest, MCTP_CTRL_HDR_MSG_TYPE,
+		&req, sizeof(req), &buf, &buf_size, &addr);
+	if (rc < 0)
+		goto out;
+
+	if (buf_size != sizeof(*resp)) {
+		warnx("%s: wrong reply %zu bytes. dest %s", __func__, buf_size,
+			dest_phys_tostr(dest));
+		rc = -ENOMSG;
+		goto out;
+	}
+	resp = (void*)buf;
+
+	if (resp->completion_code != 0x00) {
+		warnx("Failure completion code 0x%02x from %s",
+			resp->completion_code, dest_phys_tostr(dest));
+		rc = -ECONNREFUSED;
+		goto out;
+	}
+
+	memcpy(uuid, resp->uuid, 16);
+
+out:
+	free(buf);
+	return rc;
+}
+
 static int query_get_peer_uuid(peer *peer) {
 	struct sockaddr_mctp_ext addr;
 	struct mctp_ctrl_cmd_get_uuid req;
@@ -2157,6 +2222,205 @@ out:
 	return rc;
 }
 
+/* FIXME: I2C-specific */
+/* DSP0237 v1.2.0 Table 9 */
+#define MCTP_I2C_TSYM_TRECLAIM_MIN_US 5000000
+#define MCTP_I2C_TSYM_MN1_MIN 2
+#define MCTP_I2C_TSYM_MT1_MAX_US 100000
+#define MCTP_I2C_TSYM_MT3_MAX_US 100000
+#define MCTP_I2C_TSYM_MT4_MIN_US 5000000
+#define MCTP_I2C_TSYM_MT2_MIN_US \
+	(MCTP_I2C_TSYM_MT1_MAX_US + 2 * MCTP_I2C_TSYM_MT3_MAX_US)
+#define MCTP_I2C_TSYM_MT2_MAX_MS MCTP_I2C_TSYM_MT4_MIN_US
+
+static int
+peer_endpoint_recover(sd_event_source *s, uint64_t usec, void *userdata)
+{
+	int ev_state __attribute__((unused));
+	peer *peer = userdata;
+	ctx *ctx = peer->ctx;
+	char *peer_path;
+	int rc;
+
+	/*
+	 * Error handling policy:
+	 *
+	 * 1. Any resource management error prior to Treclaim is handled by
+	 *    rescheduling the poll query, unless it is scheduling the poll
+	 *    query itself that fails.
+	 *
+	 * 2. If scheduling the poll query fails then the endpoint is removed.
+	 */
+
+	peer->recovery.npolls--;
+
+	/*
+	 * Test if we still have connectivity to the endpoint. If we do, we will get a
+	 * response reporting the current EID. This is the test recommended by 8.17.6
+	 * of DSP0236 v1.3.1.
+	 */
+	rc = query_get_endpoint_id(ctx, &peer->phys, &peer->recovery.eid,
+		&peer->recovery.endpoint_type, &peer->recovery.medium_spec);
+	if (rc < 0) {
+		goto reschedule;
+	}
+
+	/*
+	 * If we've got a response there are two scenarios:
+	 *
+	 * 1. The device responds with the EID that we expect it to have
+	 * 2. The device responds with an unexpected EID, e.g. 0
+	 *
+	 * For scenario 1 we're done as the device is responsive and has the expected
+	 * address. For scenario 2, we may not yet consider the EID assignment as
+	 * expired, so check the UUID for a match. If the UUID matches we reassign the
+	 * expected EID to the device. If the UUID does not match we allocate a new
+	 * EID for the exchanged device, given it is responsive.
+	 */
+	if (peer->recovery.eid != peer->eid) {
+		static const uint8_t nil_uuid[16] = {0};
+		uint8_t uuid[16] = {0};
+		bool uuid_matches_peer;
+		bool uuid_matches_nil;
+		mctp_eid_t new_eid;
+
+		rc = query_get_peer_uuid_by_phys(ctx, &peer->phys, uuid);
+
+		static_assert(sizeof(uuid) == sizeof(nil_uuid), "Unsynchronized UUID sizes");
+
+		/*
+		 * The peer must be published for .Recover to be called, so peer->uuid must
+		 * be valid
+		 */
+		assert(peer->uuid != NULL);
+
+		/*
+		 * The memory is always valid so the memcmp() isn't unsafe, but they are only
+		 * meaningful if query_get_peer_uuid_by_phys() succeeds
+		 */
+		uuid_matches_peer = memcmp(uuid, peer->uuid, sizeof(uuid)) == 0;
+		uuid_matches_nil = memcmp(uuid, nil_uuid, sizeof(uuid)) == 0;
+
+		if (rc == 0 && !uuid_matches_nil && uuid_matches_peer) {
+			/* Confirmation of the same device, apply it's already allocated EID */
+			rc = endpoint_send_set_endpoint_id(peer, &new_eid);
+			if (rc < 0) {
+				goto reschedule;
+			}
+
+			if (new_eid != peer->eid) {
+				rc = change_peer_eid(peer, new_eid);
+				if (rc < 0) {
+					goto reclaim;
+				}
+			}
+		} else {
+			/* It's not known to be the same device, allocate a new EID */
+			dest_phys phys = peer->phys;
+
+			assert(sd_event_source_get_enabled(peer->recovery.source, &ev_state) == 0);
+			remove_peer(peer);
+			rc = endpoint_assign_eid(ctx, NULL, &phys, NULL);
+			if (rc < 0) {
+				goto reschedule;
+			}
+		}
+	}
+
+	peer->degraded = false;
+
+	rc = path_from_peer(peer, &peer_path);
+	if (rc < 0) {
+		goto reschedule;
+	}
+
+	rc = sd_bus_emit_properties_changed(ctx->bus, peer_path,
+		CC_MCTP_DBUS_IFACE_ENDPOINT, "Connectivity", NULL);
+	free(peer_path);
+	if (rc < 0) {
+		goto reschedule;
+	}
+
+	assert(sd_event_source_get_enabled(peer->recovery.source, &ev_state) == 0);
+	sd_event_source_unref(peer->recovery.source);
+	peer->recovery.delay = 0;
+	peer->recovery.source = NULL;
+	peer->recovery.npolls = 0;
+
+	return rc;
+
+reschedule:
+	if (peer->recovery.npolls > 0) {
+		rc = sd_event_source_set_time_relative(peer->recovery.source,
+			peer->recovery.delay);
+		if (rc >= 0) {
+			rc = sd_event_source_set_enabled(peer->recovery.source, SD_EVENT_ONESHOT);
+		}
+	}
+	if (rc < 0) {
+reclaim:
+		/* Recovery unsuccessful, clean up the peer */
+		assert(sd_event_source_get_enabled(peer->recovery.source, &ev_state) == 0);
+		remove_peer(peer);
+	}
+	return rc < 0 ? rc : 0;
+}
+
+static int method_endpoint_recover(sd_bus_message *call, void *data,
+	sd_bus_error *berr)
+{
+	bool previously;
+	peer *peer;
+	ctx *ctx;
+	int rc;
+
+	peer = data;
+	ctx = peer->ctx;
+	previously = peer->degraded;
+
+	if (!previously) {
+		assert(!peer->recovery.delay);
+		assert(!peer->recovery.source);
+		assert(!peer->recovery.npolls);
+		peer->recovery.npolls = MCTP_I2C_TSYM_MN1_MIN + 1;
+		peer->recovery.delay =
+			(MCTP_I2C_TSYM_TRECLAIM_MIN_US / 2) - ctx->mctp_timeout;
+		rc = sd_event_add_time_relative(ctx->event, &peer->recovery.source,
+			CLOCK_MONOTONIC, 0, ctx->mctp_timeout, peer_endpoint_recover, peer);
+		if (rc < 0) {
+			goto out;
+		}
+
+		peer->degraded = true;
+
+		rc = sd_bus_emit_properties_changed(sd_bus_message_get_bus(call),
+				sd_bus_message_get_path(call),
+				sd_bus_message_get_interface(call),
+				"Connectivity",
+				NULL);
+		if (rc < 0) {
+			goto out;
+		}
+	}
+
+	rc = sd_bus_reply_method_return(call, NULL);
+
+out:
+	if (rc < 0 && !previously) {
+		if (peer->degraded) {
+			/* Cleanup the timer if it was setup successfully. */
+			sd_event_source_set_enabled(peer->recovery.source, SD_EVENT_OFF);
+			sd_event_source_unref(peer->recovery.source);
+		}
+		peer->degraded = previously;
+		peer->recovery.delay = 0;
+		peer->recovery.source = NULL;
+		peer->recovery.npolls = 0;
+	}
+	set_berr(ctx, rc, berr);
+	return rc;
+}
+
 static int method_endpoint_set_mtu(sd_bus_message *call, void *data,
 	sd_bus_error *berr)
 {
@@ -2337,6 +2601,8 @@ static int bus_endpoint_get_prop(sd_bus *bus,
 	} else if (strcmp(property, "UUID") == 0 && peer->uuid) {
 		const char *s = dfree(bytes_to_uuid(peer->uuid));
 		rc = sd_bus_message_append(reply, "s", s);
+	} else if (strcmp(property, "Connectivity") == 0) {
+		rc = sd_bus_message_append(reply, "s", peer->degraded ? "Degraded" : "Available");
 	} else {
 		printf("Unknown property '%s' for %s iface %s\n", property, path, interface);
 		rc = -ENOENT;
@@ -2387,6 +2653,16 @@ static const sd_bus_vtable bus_endpoint_cc_vtable[] = {
 		SD_BUS_NO_RESULT,
 		method_endpoint_remove,
 		0),
+	SD_BUS_METHOD("Recover",
+		SD_BUS_NO_ARGS,
+		SD_BUS_NO_RESULT,
+		method_endpoint_recover,
+		0),
+	SD_BUS_PROPERTY("Connectivity",
+		"s",
+		bus_endpoint_get_prop,
+		0,
+		SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE),
 	SD_BUS_VTABLE_END
 };
 
-- 
2.25.1

