From 5926a8daac322fa48beaaa56ee85b3faba308d30 Mon Sep 17 00:00:00 2001
From: Chau Ly <chaul@amperecomputing.com>
Date: Tue, 19 Mar 2024 12:33:08 +0000
Subject: [PATCH 37/40] platform-mc: Handle `Connectivity` propertiesChanged
 signal

mctpd supports `.Connectivity` property under
`au.com.CodeConstruct.MCTP.Endpoint` interface of the endpoint. This
commit handles the propertiesChanged signal from this interface, and
updates the Availability of the MCTP Endpoint accordingly in the source
to enable or disable message sending/receiving via that endpoint of the
terminus.

When the discovery process first starts, it will only handle the
endpoints that have `Available` `.Connectivity`. It lets the
propertiesChanged signal trigger the adding of the endpoints when they
are back to` Available`.

On interfaceAdded signal, it assumes that mctpd only publishes available
endpoints to D-Bus, so it adds the endpoints to the terminus anyway.

Tested:
1. Enable `unsafe-writable-connectivity` option in PACKAGECONFIG of mctp
recipe.
2. After PLDM discovers all the endpoints, write `Degraded` to
`.Connectivity` of one of the endpoint.
3. Write it back to `Available` to see how message is stopped from being
sent/received via the endpoint.

Signed-off-by: Chau Ly <chaul@amperecomputing.com>
Signed-off-by: Thu Nguyen <thu@os.amperecomputing.com>
Change-Id: I5b7a38ae72e655b60d71396a1118f2809aaa3838
---
 common/types.hpp                              |  11 +
 fw-update/manager.hpp                         |  11 +
 platform-mc/manager.hpp                       |  18 ++
 platform-mc/terminus_manager.cpp              |  43 +++-
 platform-mc/terminus_manager.hpp              |  11 +
 platform-mc/test/platform_manager_test.cpp    |  49 ++++
 requester/mctp_endpoint_discovery.cpp         | 211 +++++++++++++++---
 requester/mctp_endpoint_discovery.hpp         |  49 +++-
 .../test/mctp_endpoint_discovery_test.cpp     |   7 +-
 .../test/mock_mctp_discovery_handler_intf.hpp |   3 +
 10 files changed, 373 insertions(+), 40 deletions(-)

diff --git a/common/types.hpp b/common/types.hpp
index 661c2e7..9720a25 100644
--- a/common/types.hpp
+++ b/common/types.hpp
@@ -20,6 +20,7 @@ using eid = uint8_t;
 using UUID = std::string;
 using Request = std::vector<uint8_t>;
 using Response = std::vector<uint8_t>;
+using MCTPMsgTypes = std::vector<uint8_t>;
 using Command = uint8_t;
 
 /** @brief MCTP Endpoint Medium type in string
@@ -41,6 +42,16 @@ using NetworkId = uint32_t;
  */
 using MctpInfo = std::tuple<eid, UUID, MctpMedium, NetworkId>;
 
+/** @brief Type definition of MCTP endpoint D-Bus properties in
+ *         xyz.openbmc_project.MCTP.Endpoint D-Bus interface.
+ *
+ *         NetworkId: MCTP network index
+ *         eid : Endpoint EID in byte. Defined to match with MCTP D-Bus
+ *               interface
+ *         MCTPMsgTypes: MCTP message types
+ */
+using MctpEndpointProps = std::tuple<NetworkId, eid, MCTPMsgTypes>;
+
 /** @brief Type defined for list of MCTP interface information
  */
 using MctpInfos = std::vector<MctpInfo>;
diff --git a/fw-update/manager.hpp b/fw-update/manager.hpp
index be45eb7..7ffd1e3 100644
--- a/fw-update/manager.hpp
+++ b/fw-update/manager.hpp
@@ -71,6 +71,17 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         return;
     }
 
+    /** @brief Helper function to invoke registered handlers for
+     *  updating the availability status of the MCTP endpoint
+     *
+     *  @param[in] mctpInfo - information of the target endpoint
+     *  @param[in] availability - new availability status
+     */
+    void updateMctpEndpointAvailability(const MctpInfo&, Availability)
+    {
+        return;
+    }
+
     /** @brief Handle PLDM request for the commands in the FW update
      *         specification
      *
diff --git a/platform-mc/manager.hpp b/platform-mc/manager.hpp
index e6d5769..cdad31e 100644
--- a/platform-mc/manager.hpp
+++ b/platform-mc/manager.hpp
@@ -79,6 +79,24 @@ class Manager : public pldm::MctpDiscoveryHandlerIntf
         terminusManager.removeMctpTerminus(mctpInfos);
     }
 
+    /** @brief Helper function to invoke registered handlers for
+     *  updating the availability status of the MCTP endpoint
+     *
+     *  @param[in] mctpInfo - information of the target endpoint
+     *  @param[in] availability - new availability status
+     */
+    void updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                        Availability availability)
+    {
+        /* Get TID of initialized terminus */
+        auto tid = terminusManager.toTid(mctpInfo);
+        if (tid)
+        {
+            updateAvailableState(tid.value(), availability);
+        }
+        terminusManager.updateMctpEndpointAvailability(mctpInfo, availability);
+    }
+
     /** @brief Helper function to start sensor polling of the terminus TID
      */
     void startSensorPolling(pldm_tid_t tid)
diff --git a/platform-mc/terminus_manager.cpp b/platform-mc/terminus_manager.cpp
index c5d3f53..2bbc08b 100644
--- a/platform-mc/terminus_manager.cpp
+++ b/platform-mc/terminus_manager.cpp
@@ -125,6 +125,29 @@ bool TerminusManager::unmapTid(const pldm_tid_t& tid)
     return true;
 }
 
+void TerminusManager::updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                                     Availability availability)
+{
+    auto mctpInfoIt = mctpInfoAvailTable.find(mctpInfo);
+    if (mctpInfoIt != mctpInfoAvailTable.end())
+    {
+        mctpInfoIt->second = availability;
+    }
+    else
+    {
+        mctpInfoAvailTable[mctpInfo] = availability;
+    }
+
+    if (manager)
+    {
+        auto tid = toTid(mctpInfo);
+        if (tid)
+        {
+            manager->updateAvailableState(tid.value(), availability);
+        }
+    }
+}
+
 void TerminusManager::discoverMctpTerminus(const MctpInfos& mctpInfos)
 {
     queuedMctpInfos.emplace(mctpInfos);
@@ -174,6 +197,7 @@ exec::task<int> TerminusManager::discoverMctpTerminusTask()
             auto it = findTerminusPtr(mctpInfo);
             if (it == termini.end())
             {
+                mctpInfoAvailTable[mctpInfo] = true;
                 co_await initMctpTerminus(mctpInfo);
             }
 
@@ -181,6 +205,7 @@ exec::task<int> TerminusManager::discoverMctpTerminusTask()
             auto tid = toTid(mctpInfo);
             if (!tid)
             {
+                mctpInfoAvailTable.erase(mctpInfo);
                 co_return PLDM_ERROR;
             }
             addedTids.push_back(tid.value());
@@ -219,6 +244,11 @@ void TerminusManager::removeMctpTerminus(const MctpInfos& mctpInfos)
 
         unmapTid(it->first);
         termini.erase(it);
+
+        if (mctpInfoAvailTable.contains(mctpInfo))
+        {
+            mctpInfoAvailTable.erase(mctpInfo);
+        }
     }
 }
 
@@ -611,7 +641,18 @@ exec::task<int> TerminusManager::sendRecvPldmMsg(pldm_tid_t tid,
     }
 
     auto mctpInfo = toMctpInfo(tid);
-    if (!mctpInfo.has_value())
+    if (!mctpInfo)
+    {
+        co_return PLDM_ERROR_NOT_READY;
+    }
+
+    // There's a cost of maintaining another table to hold availability
+    // status as we can't ensure that it always synchronizes with the
+    // mctpInfoTable; std::map operator[] will insert a default of boolean
+    // which is false to the mctpInfoAvailTable if the mctpInfo key doesn't
+    // exist. Once we miss to initialize the availability of an available
+    // endpoint, it will drop all the messages to/from it.
+    if (!mctpInfoAvailTable[mctpInfo.value()])
     {
         co_return PLDM_ERROR_NOT_READY;
     }
diff --git a/platform-mc/terminus_manager.hpp b/platform-mc/terminus_manager.hpp
index 5e9f8a7..741c75f 100644
--- a/platform-mc/terminus_manager.hpp
+++ b/platform-mc/terminus_manager.hpp
@@ -157,6 +157,15 @@ class TerminusManager
         return localEid;
     }
 
+    /** @brief Helper function to invoke registered handlers for
+     *  updating the availability status of the MCTP endpoint
+     *
+     *  @param[in] mctpInfo - information of the target endpoint
+     *  @param[in] availability - new availability status
+     */
+    void updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                        Availability availability);
+
   private:
     /** @brief Find the terminus object pointer in termini list.
      *
@@ -252,6 +261,8 @@ class TerminusManager
 
     /** @brief A Manager interface for calling the hook functions **/
     Manager* manager;
+
+    std::map<MctpInfo, Availability> mctpInfoAvailTable;
 };
 } // namespace platform_mc
 } // namespace pldm
diff --git a/platform-mc/test/platform_manager_test.cpp b/platform-mc/test/platform_manager_test.cpp
index 774ec6d..3ccb50a 100644
--- a/platform-mc/test/platform_manager_test.cpp
+++ b/platform-mc/test/platform_manager_test.cpp
@@ -186,6 +186,52 @@ TEST_F(PlatformManagerTest, initTerminusTest)
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(2, terminus->pdrs.size());
     EXPECT_EQ(1, terminus->numericSensors.size());
+<<<<<<< HEAD
+=======
+    const size_t getPdrAuxNameRespLen = 39;
+    std::array<uint8_t, sizeof(pldm_msg_hdr) + getPdrAuxNameRespLen>
+        getPdrAuxNameResp{
+            0x0, 0x02, 0x51, PLDM_SUCCESS, 0x0, 0x0, 0x0,
+            0x0,                // nextRecordHandle
+            0x0, 0x0, 0x0, 0x0, // nextDataTransferHandle
+            0x5,                // transferFlag
+            0x1b, 0x0,          // responseCount
+            // Common PDR Header
+            0x1, 0x0, 0x0,
+            0x0,                             // record handle
+            0x1,                             // PDRHeaderVersion
+            PLDM_ENTITY_AUXILIARY_NAMES_PDR, // PDRType
+            0x1,
+            0x0,                             // recordChangeNumber
+            0x11,
+            0,                               // dataLength
+            /* Entity Auxiliary Names PDR Data*/
+            3,
+            0x80, // entityType system software
+            0x1,
+            0x0,  // Entity instance number =1
+            0,
+            0,    // Overal system
+            0,    // shared Name Count one name only
+            01,   // nameStringCount
+            0x65, 0x6e, 0x00,
+            0x00, // Language Tag "en"
+            0x53, 0x00, 0x30, 0x00,
+            0x00  // Entity Name "S0"
+        };
+    rc = mockTerminusManager.enqueueResponse(
+        (pldm_msg*)getPdrAuxNameResp.data(), sizeof(getPdrAuxNameResp));
+    EXPECT_EQ(rc, PLDM_SUCCESS);
+
+    mockTerminusManager.updateMctpEndpointAvailability(
+        pldm::MctpInfo(10, "", "", 1), true);
+
+    stdexec::sync_wait(platformManager.initTerminus());
+    EXPECT_EQ(true, terminus->initialized);
+    EXPECT_EQ(true, terminus->doesSupportCommand(PLDM_PLATFORM, PLDM_GET_PDR));
+    EXPECT_EQ(2, terminus->pdrs.size());
+    EXPECT_EQ(1, terminus->numericSensors.size());
+>>>>>>> 6e0717b... platform-mc: Handle `Connectivity` propertiesChanged signal
     EXPECT_EQ("S0", terminus->getTerminusName());
 }
 
@@ -340,6 +386,9 @@ TEST_F(PlatformManagerTest, parseTerminusNameTest)
         (pldm_msg*)getPdrAuxNameResp.data(), sizeof(getPdrAuxNameResp));
     EXPECT_EQ(rc, PLDM_SUCCESS);
 
+    mockTerminusManager.updateMctpEndpointAvailability(
+        pldm::MctpInfo(10, "", "", 1), true);
+
     stdexec::sync_wait(platformManager.initTerminus());
     EXPECT_EQ(true, terminus->initialized);
     EXPECT_EQ(2, terminus->pdrs.size());
diff --git a/requester/mctp_endpoint_discovery.cpp b/requester/mctp_endpoint_discovery.cpp
index 2780281..e5f4d9b 100644
--- a/requester/mctp_endpoint_discovery.cpp
+++ b/requester/mctp_endpoint_discovery.cpp
@@ -5,6 +5,8 @@
 #include "common/types.hpp"
 #include "common/utils.hpp"
 
+#include <linux/mctp.h>
+
 #include <phosphor-logging/lg2.hpp>
 
 #include <algorithm>
@@ -25,6 +27,9 @@ MctpDiscovery::MctpDiscovery(
     sdbusplus::bus_t& bus,
     std::initializer_list<MctpDiscoveryHandlerIntf*> list) :
     bus(bus),
+    mctpEndpointPropChangedSignal(
+        bus, propertiesChangedNamespace(MCTPPath, MCTPInterfaceCC),
+        std::bind_front(&MctpDiscovery::propertiesChangedCb, this)),
     mctpEndpointAddedSignal(
         bus, interfacesAdded(MCTPPath),
         std::bind_front(&MctpDiscovery::discoverEndpoints, this)),
@@ -33,11 +38,22 @@ MctpDiscovery::MctpDiscovery(
         std::bind_front(&MctpDiscovery::removeEndpoints, this)),
     handlers(list)
 {
-    getMctpInfos(existingMctpInfos);
+    std::map<MctpInfo, Availability> currentMctpInfoMap;
+    getMctpInfos(currentMctpInfoMap);
+    for (const auto& mapIt : currentMctpInfoMap)
+    {
+        if (mapIt.second)
+        {
+            // Only add the available endpoints to the terminus
+            // Let the propertiesChanged signal tells us when it comes back
+            // to Available again
+            addToExistingMctpInfos(MctpInfos(1, mapIt.first));
+        }
+    }
     handleMctpEndpoints(existingMctpInfos);
 }
 
-void MctpDiscovery::getMctpInfos(MctpInfos& mctpInfos)
+void MctpDiscovery::getMctpInfos(std::map<MctpInfo, Availability>& mctpInfoMap)
 {
     // Find all implementations of the MCTP Endpoint interface
     pldm::utils::GetSubTreeResponse mapperResponse;
@@ -59,43 +75,75 @@ void MctpDiscovery::getMctpInfos(MctpInfos& mctpInfos)
         for (const auto& serviceIter : services)
         {
             const std::string& service = serviceIter.first;
-            try
+            const MctpEndpointProps& epProps = getMctpEndpointProps(service,
+                                                                    path);
+            const Availability& availability =
+                getEndpointConnectivityProp(path);
+            auto types = std::get<MCTPMsgTypes>(epProps);
+            if (std::find(types.begin(), types.end(), mctpTypePLDM) !=
+                types.end())
             {
-                auto properties =
-                    pldm::utils::DBusHandler().getDbusPropertiesVariant(
-                        service.c_str(), path.c_str(), MCTPInterface);
-
-                if (properties.contains("NetworkId") &&
-                    properties.contains("EID") &&
-                    properties.contains("SupportedMessageTypes"))
-                {
-                    auto networkId =
-                        std::get<NetworkId>(properties.at("NetworkId"));
-                    auto eid = std::get<mctp_eid_t>(properties.at("EID"));
-                    auto types = std::get<std::vector<uint8_t>>(
-                        properties.at("SupportedMessageTypes"));
-                    if (std::find(types.begin(), types.end(), mctpTypePLDM) !=
-                        types.end())
-                    {
-                        info(
-                            "Adding Endpoint networkId '{NETWORK}' and EID '{EID}'",
-                            "NETWORK", networkId, "EID", eid);
-                        mctpInfos.emplace_back(
-                            MctpInfo(eid, emptyUUID, "", networkId));
-                    }
-                }
-            }
-            catch (const sdbusplus::exception_t& e)
-            {
-                error(
-                    "Error reading MCTP Endpoint property at path '{PATH}' and service '{SERVICE}', error - {ERROR}",
-                    "ERROR", e, "SERVICE", service, "PATH", path);
-                return;
+                mctpInfoMap[MctpInfo(std::get<eid>(epProps), emptyUUID, "",
+                                     std::get<NetworkId>(epProps))] =
+                    availability;
             }
         }
     }
 }
 
+MctpEndpointProps
+    MctpDiscovery::getMctpEndpointProps(const std::string& service,
+                                        const std::string& path)
+{
+    try
+    {
+        auto properties = pldm::utils::DBusHandler().getDbusPropertiesVariant(
+            service.c_str(), path.c_str(), MCTPInterface);
+
+        if (properties.contains("NetworkId") && properties.contains("EID") &&
+            properties.contains("SupportedMessageTypes"))
+        {
+            auto networkId = std::get<NetworkId>(properties.at("NetworkId"));
+            auto eid = std::get<mctp_eid_t>(properties.at("EID"));
+            auto types = std::get<std::vector<uint8_t>>(
+                properties.at("SupportedMessageTypes"));
+            return MctpEndpointProps(networkId, eid, types);
+        }
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        error(
+            "Error reading MCTP Endpoint property at path '{PATH}' and service '{SERVICE}', error - {ERROR}",
+            "SERVICE", service, "PATH", path, "ERROR", e);
+        return MctpEndpointProps(0, MCTP_ADDR_ANY, {});
+    }
+
+    return MctpEndpointProps(0, MCTP_ADDR_ANY, {});
+}
+
+Availability MctpDiscovery::getEndpointConnectivityProp(const std::string& path)
+{
+    Availability available = false;
+    try
+    {
+        pldm::utils::PropertyValue propertyValue =
+            pldm::utils::DBusHandler().getDbusPropertyVariant(
+                path.c_str(), MCTPConnectivityProp, MCTPInterfaceCC);
+        if (std::get<std::string>(propertyValue) == "Available")
+        {
+            available = true;
+        }
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        error(
+            "Error reading Endpoint Connectivity property at path '{PATH}', error - {ERROR}",
+            "PATH", path, "ERROR", e);
+    }
+
+    return available;
+}
+
 void MctpDiscovery::getAddedMctpInfos(sdbusplus::message_t& msg,
                                       MctpInfos& mctpInfos)
 {
@@ -116,6 +164,7 @@ void MctpDiscovery::getAddedMctpInfos(sdbusplus::message_t& msg,
             "ERROR", e);
         return;
     }
+    const Availability& availability = getEndpointConnectivityProp(objPath.str);
 
     for (const auto& [intfName, properties] : interfaces)
     {
@@ -130,6 +179,15 @@ void MctpDiscovery::getAddedMctpInfos(sdbusplus::message_t& msg,
                 auto eid = std::get<mctp_eid_t>(properties.at("EID"));
                 auto types = std::get<std::vector<uint8_t>>(
                     properties.at("SupportedMessageTypes"));
+
+                if (!availability)
+                {
+                    // Log an error message here, but still add it to the
+                    // terminus
+                    error(
+                        "mctpd added a DEGRADED endpoint {EID} networkId {NET} to D-Bus",
+                        "NET", networkId, "EID", static_cast<unsigned>(eid));
+                }
                 if (std::find(types.begin(), types.end(), mctpTypePLDM) !=
                     types.end())
                 {
@@ -177,6 +235,74 @@ void MctpDiscovery::removeFromExistingMctpInfos(MctpInfos& mctpInfos,
     }
 }
 
+void MctpDiscovery::propertiesChangedCb(sdbusplus::message_t& msg)
+{
+    using Interface = std::string;
+    using Property = std::string;
+    using Value = std::string;
+    using Properties = std::map<Property, std::variant<Value>>;
+
+    Interface interface;
+    Properties properties;
+    std::string objPath{};
+    std::string service{};
+
+    try
+    {
+        msg.read(interface, properties);
+        objPath = msg.get_path();
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        error(
+            "Error handling Connectivity property changed message, error - {ERROR}",
+            "ERROR", e);
+        return;
+    }
+
+    for (const auto& [key, valueVariant] : properties)
+    {
+        Value propVal = std::get<std::string>(valueVariant);
+        auto availability = (propVal == "Available") ? true : false;
+
+        if (key == MCTPConnectivityProp)
+        {
+            service = pldm::utils::DBusHandler().getService(objPath.c_str(),
+                                                            MCTPInterface);
+            const MctpEndpointProps& epProps = getMctpEndpointProps(service,
+                                                                    objPath);
+
+            auto types = std::get<MCTPMsgTypes>(epProps);
+            if (std::find(types.begin(), types.end(), mctpTypePLDM) ==
+                types.end())
+            {
+                return;
+            }
+
+            MctpInfo mctpInfo(std::get<eid>(epProps), emptyUUID, "",
+                              std::get<NetworkId>(epProps));
+            auto existingMatchIt = std::find(existingMctpInfos.begin(),
+                                             existingMctpInfos.end(), mctpInfo);
+            if (existingMatchIt == existingMctpInfos.end() && availability)
+            {
+                // The endpoint not in existingMctpInfos and is
+                // available Add it to existingMctpInfos
+                info(
+                    "Adding Endpoint networkId={NETWORK} EID={EID} by propertiesChanged signal",
+                    "NETWORK", std::get<3>(mctpInfo), "EID",
+                    unsigned(std::get<0>(mctpInfo)));
+                addToExistingMctpInfos(MctpInfos(1, mctpInfo));
+                handleMctpEndpoints(MctpInfos(1, mctpInfo));
+            }
+            else if (existingMatchIt != existingMctpInfos.end())
+            {
+                // The endpoint already in existingMctpInfos
+                updateMctpEndpointAvailability(mctpInfo, availability);
+            }
+        }
+    }
+}
+
 void MctpDiscovery::discoverEndpoints(sdbusplus::message_t& msg)
 {
     MctpInfos addedInfos;
@@ -189,7 +315,12 @@ void MctpDiscovery::removeEndpoints(sdbusplus::message_t&)
 {
     MctpInfos mctpInfos;
     MctpInfos removedInfos;
-    getMctpInfos(mctpInfos);
+    std::map<MctpInfo, Availability> currentMctpInfoMap;
+    getMctpInfos(currentMctpInfoMap);
+    for (const auto& mapIt : currentMctpInfoMap)
+    {
+        mctpInfos.push_back(mapIt.first);
+    }
     removeFromExistingMctpInfos(mctpInfos, removedInfos);
     handleRemovedMctpEndpoints(removedInfos);
 }
@@ -216,4 +347,16 @@ void MctpDiscovery::handleRemovedMctpEndpoints(const MctpInfos& mctpInfos)
     }
 }
 
+void MctpDiscovery::updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                                   Availability availability)
+{
+    for (const auto& handler : handlers)
+    {
+        if (handler)
+        {
+            handler->updateMctpEndpointAvailability(mctpInfo, availability);
+        }
+    }
+}
+
 } // namespace pldm
diff --git a/requester/mctp_endpoint_discovery.hpp b/requester/mctp_endpoint_discovery.hpp
index 643d1ce..df992e2 100644
--- a/requester/mctp_endpoint_discovery.hpp
+++ b/requester/mctp_endpoint_discovery.hpp
@@ -17,7 +17,9 @@ namespace pldm
 const std::string emptyUUID = "00000000-0000-0000-0000-000000000000";
 constexpr const char* MCTPService = "xyz.openbmc_project.MCTP";
 constexpr const char* MCTPInterface = "xyz.openbmc_project.MCTP.Endpoint";
+constexpr const char* MCTPInterfaceCC = "au.com.CodeConstruct.MCTP.Endpoint";
 constexpr const char* MCTPPath = "/xyz/openbmc_project/mctp";
+constexpr const char* MCTPConnectivityProp = "Connectivity";
 
 /** @class MctpDiscoveryHandlerIntf
  *
@@ -29,6 +31,8 @@ class MctpDiscoveryHandlerIntf
   public:
     virtual void handleMctpEndpoints(const MctpInfos& mctpInfos) = 0;
     virtual void handleRemovedMctpEndpoints(const MctpInfos& mctpInfos) = 0;
+    virtual void updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                                Availability availability) = 0;
     virtual ~MctpDiscoveryHandlerIntf() {}
 };
 
@@ -55,6 +59,9 @@ class MctpDiscovery
     /** @brief reference to the systemd bus */
     sdbusplus::bus_t& bus;
 
+    /** @brief Used to watch for new MCTP endpoints */
+    sdbusplus::bus::match_t mctpEndpointPropChangedSignal;
+
     /** @brief Used to watch for new MCTP endpoints */
     sdbusplus::bus::match_t mctpEndpointAddedSignal;
 
@@ -68,6 +75,13 @@ class MctpDiscovery
     /** @brief The existing MCTP endpoints */
     MctpInfos existingMctpInfos;
 
+    /** @brief Callback function when the propertiesChanged D-Bus
+     * signal is triggered for MCTP endpoint's properties.
+     *
+     *  @param[in] msg - Data associated with subscribed signal
+     */
+    void propertiesChangedCb(sdbusplus::message_t& msg);
+
     /** @brief Callback function when MCTP endpoints addedInterface
      * D-Bus signal raised.
      *
@@ -96,11 +110,21 @@ class MctpDiscovery
      */
     void handleRemovedMctpEndpoints(const MctpInfos& mctpInfos);
 
+    /** @brief Helper function to invoke registered handlers for
+     *  updating the availability status of the MCTP endpoint
+     *
+     *  @param[in] mctpInfo - information of the target endpoint
+     *  @param[in] availability - new availability status
+     */
+    void updateMctpEndpointAvailability(const MctpInfo& mctpInfo,
+                                        Availability availability);
+
     /** @brief Get list of MctpInfos in MCTP control interface.
      *
-     *  @param[in] mctpInfos - information of discovered MCTP endpoints
+     *  @param[in] mctpInfoMap - information of discovered MCTP endpoints
+     *  and the availability status of each endpoint
      */
-    void getMctpInfos(MctpInfos& mctpInfos);
+    void getMctpInfos(std::map<MctpInfo, Availability>& mctpInfoMap);
 
     /** @brief Get list of new MctpInfos in addedInterace D-Bus signal message.
      *
@@ -124,6 +148,27 @@ class MctpDiscovery
                                      MctpInfos& removedInfos);
 
   private:
+    /** @brief Get MCTP Endpoint D-Bus Properties in the
+     *         `xyz.openbmc_project.MCTP.Endpoint` D-Bus interface
+     *
+     *  @param[in] service - the MCTP service name
+     *  @param[in] path - the MCTP endpoints object path
+     *
+     *  @return tuple of Network Index, Endpoint ID and MCTP message types
+     */
+    MctpEndpointProps getMctpEndpointProps(const std::string& service,
+                                           const std::string& path);
+
+    /** @brief Get Endpoint Availability status from `Connectivity` D-Bus
+     *         property in the `au.com.codeconstruct.MCTP.Endpoint1` D-Bus
+     *         interface.
+     *
+     *  @param[in] path - the MCTP endpoints object path
+     *
+     *  @return Availability status: true if active false if inactive
+     */
+    Availability getEndpointConnectivityProp(const std::string& path);
+
     static constexpr uint8_t mctpTypePLDM = 1;
 };
 
diff --git a/requester/test/mctp_endpoint_discovery_test.cpp b/requester/test/mctp_endpoint_discovery_test.cpp
index df390a0..5c55df9 100644
--- a/requester/test/mctp_endpoint_discovery_test.cpp
+++ b/requester/test/mctp_endpoint_discovery_test.cpp
@@ -1,5 +1,6 @@
 #include "config.h"
 
+#include "common/types.hpp"
 #include "common/utils.hpp"
 #include "requester/test/mock_mctp_discovery_handler_intf.hpp"
 
@@ -39,12 +40,12 @@ TEST(MctpEndpointDiscoveryTest, goodGetMctpInfos)
 {
     auto& bus = pldm::utils::DBusHandler::getBus();
     pldm::MockManager manager;
-    pldm::MctpInfos mctpInfos;
+    std::map<pldm::MctpInfo, pldm::Availability> currentMctpInfoMap;
 
     auto mctpDiscoveryHandler = std::make_unique<pldm::MctpDiscovery>(
         bus, std::initializer_list<pldm::MctpDiscoveryHandlerIntf*>{&manager});
-    mctpDiscoveryHandler->getMctpInfos(mctpInfos);
-    EXPECT_EQ(mctpInfos.size(), 0);
+    mctpDiscoveryHandler->getMctpInfos(currentMctpInfoMap);
+    EXPECT_EQ(currentMctpInfoMap.size(), 0);
 }
 
 TEST(MctpEndpointDiscoveryTest, goodAddToExistingMctpInfos)
diff --git a/requester/test/mock_mctp_discovery_handler_intf.hpp b/requester/test/mock_mctp_discovery_handler_intf.hpp
index 8aada96..02de8c5 100644
--- a/requester/test/mock_mctp_discovery_handler_intf.hpp
+++ b/requester/test/mock_mctp_discovery_handler_intf.hpp
@@ -15,6 +15,9 @@ class MockManager : public pldm::MctpDiscoveryHandlerIntf
                 (override));
     MOCK_METHOD(void, handleRemovedMctpEndpoints, (const MctpInfos& mctpInfos),
                 (override));
+    MOCK_METHOD(void, updateMctpEndpointAvailability,
+                (const MctpInfo& mctpInfo, Availability availability),
+                (override));
 };
 
 } // namespace pldm
-- 
2.25.1

